<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN Pooling Operations - 3 Minute ML Lecture</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .lecture-container {
            max-width: 900px;
            margin: 90px auto 0;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .lecture-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 10px;
        }
        
        .section {
            margin-bottom: 25px;
            padding: 20px;
            border-left: 4px solid #667eea;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 10px 0;
        }
        
        .highlight {
            background: #e74c3c;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .pooling-demo {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .pooling-type {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #667eea;
        }
        
        .matrix {
            font-family: monospace;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        .comparison-table th {
            background: #667eea;
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f2f2f2;
        }
    </style>
</head>
<body>
    <div class="lecture-container">
        <div class="lecture-header">
            <h1>üèä‚Äç‚ôÇÔ∏è CNN Pooling Operations</h1>
            <h2>Downsampling and Feature Reduction in CNNs</h2>
            <p>Master the art of pooling: Max, Average, Global, and Adaptive</p>
        </div>

        <div class="section">
            <h3>üéØ What is Pooling?</h3>
            <p><strong>Pooling</strong> is a downsampling operation that reduces the spatial dimensions of feature maps while retaining important information.</p>
            <br>
            <h4>Key Benefits:</h4>
            <ul>
                <li><span class="highlight">Dimensionality Reduction</span>: Reduces computational load</li>
                <li><span class="highlight">Translation Invariance</span>: Makes features less sensitive to small shifts</li>
                <li><span class="highlight">Feature Abstraction</span>: Focuses on dominant features</li>
                <li><span class="highlight">Overfitting Prevention</span>: Acts as regularization</li>
            </ul>
        </div>

        <div class="section">
            <h3>üî• Max Pooling</h3>
            <p><strong>Max pooling</strong> selects the maximum value from each pooling window. It's the most common pooling operation.</p>
            <br>
            <div class="pooling-demo">
                <div class="pooling-type">
                    <h4>Input Feature Map (4√ó4)</h4>
                    <div class="matrix">
                        1.2  3.4  2.1  0.8<br>
                        4.5  8.9  1.3  2.7<br>
                        0.9  2.3  6.7  3.2<br>
                        1.8  0.5  4.1  7.6
                    </div>
                </div>
                
                <div class="pooling-type">
                    <h4>Max Pooled (2√ó2)</h4>
                    <div class="matrix">
                        8.9  2.7<br>
                        2.3  7.6
                    </div>
                    <p><small>Pool size: 2√ó2, Stride: 2</small></p>
                </div>
            </div>

            <div class="code-block">
def max_pooling_2d(input_map, pool_size=2, stride=2):<br>
    h, w = input_map.shape<br>
    out_h = (h - pool_size) // stride + 1<br>
    out_w = (w - pool_size) // stride + 1<br>
    <br>
    output = np.zeros((out_h, out_w))<br>
    <br>
    for i in range(out_h):<br>
        for j in range(out_w):<br>
            start_i = i * stride<br>
            start_j = j * stride<br>
            end_i = start_i + pool_size<br>
            end_j = start_j + pool_size<br>
            <br>
            window = input_map[start_i:end_i, start_j:end_j]<br>
            output[i, j] = np.max(window)<br>
    <br>
    return output
            </div>
            <br>
            <h4>Characteristics:</h4>
            <ul>
                <li>Preserves strongest activations</li>
                <li>Provides translation invariance</li>
                <li>Non-learnable operation</li>
                <li>Commonly uses 2√ó2 windows with stride 2</li>
            </ul>
        </div>

        <div class="section">
            <h3>üìä Average Pooling</h3>
            <p><strong>Average pooling</strong> computes the average value within each pooling window.</p>
            <br>
            <div class="pooling-demo">
                <div class="pooling-type">
                    <h4>Input Feature Map (4√ó4)</h4>
                    <div class="matrix">
                        1.2  3.4  2.1  0.8<br>
                        4.5  8.9  1.3  2.7<br>
                        0.9  2.3  6.7  3.2<br>
                        1.8  0.5  4.1  7.6
                    </div>
                </div>
                
                <div class="pooling-type">
                    <h4>Average Pooled (2√ó2)</h4>
                    <div class="matrix">
                        4.5  1.7<br>
                        1.4  5.4
                    </div>
                    <p><small>Pool size: 2√ó2, Stride: 2</small></p>
                </div>
            </div>

            <div class="code-block">
def average_pooling_2d(input_map, pool_size=2, stride=2):<br>
    h, w = input_map.shape<br>
    out_h = (h - pool_size) // stride + 1<br>
    out_w = (w - pool_size) // stride + 1<br>
    <br>
    output = np.zeros((out_h, out_w))<br>
    <br>
    for i in range(out_h):<br>
        for j in range(out_w):<br>
            start_i = i * stride<br>
            start_j = j * stride<br>
            end_i = start_i + pool_size<br>
            end_j = start_j + pool_size<br>
            <br>
            window = input_map[start_i:end_i, start_j:end_j]<br>
            output[i, j] = np.mean(window)<br>
    <br>
    return output
            </div>
            <br>
            <h4>Characteristics:</h4>
            <ul>
                <li>Smooths feature maps</li>
                <li>Reduces noise</li>
                <li>Less aggressive than max pooling</li>
                <li>Better for preserving overall feature distribution</li>
            </ul>
        </div>

        <div class="section">
            <h3>üåç Global Pooling</h3>
            <p><strong>Global pooling</strong> reduces each feature map to a single value by pooling over the entire spatial dimensions.</p>
            <br>
            <div class="pooling-demo">
                <div class="pooling-type">
                    <h4>Global Max Pooling</h4>
                    <div class="matrix">
                        Input (4√ó4) ‚Üí Single Value<br>
                        Max = 8.9
                    </div>
                    <p>Takes maximum across entire feature map</p>
                </div>
                
                <div class="pooling-type">
                    <h4>Global Average Pooling</h4>
                    <div class="matrix">
                        Input (4√ó4) ‚Üí Single Value<br>
                        Average = 3.2
                    </div>
                    <p>Takes average across entire feature map</p>
                </div>
            </div>

            <div class="code-block">
# Global Max Pooling<br>
def global_max_pooling(input_map):<br>
    return np.max(input_map)<br>
<br>
# Global Average Pooling<br>  
def global_average_pooling(input_map):<br>
    return np.mean(input_map)<br>
<br>
# TensorFlow/Keras implementation<br>
model.add(keras.layers.GlobalMaxPooling2D())<br>
model.add(keras.layers.GlobalAveragePooling2D())
            </div>
            <br>
            <h4>Use Cases:</h4>
            <ul>
                <li>Replacing fully connected layers</li>
                <li>Reducing parameters dramatically</li>
                <li>Classification tasks</li>
                <li>Modern CNN architectures (ResNet, MobileNet)</li>
            </ul>
        </div>

        <div class="section">
            <h3>üéØ Adaptive Pooling</h3>
            <p><strong>Adaptive pooling</strong> produces output of fixed size regardless of input size by automatically adjusting the pooling window and stride.</p>
            <br>
            <div class="pooling-demo">
                <div class="pooling-type">
                    <h4>Variable Input Sizes</h4>
                    <div class="matrix">
                        8√ó8 ‚Üí 3√ó3<br>
                        12√ó12 ‚Üí 3√ó3<br>
                        16√ó16 ‚Üí 3√ó3
                    </div>
                    <p>Same output size regardless of input</p>
                </div>
                
                <div class="pooling-type">
                    <h4>Adaptive Window</h4>
                    <div class="matrix">
                        Window size adjusts<br>
                        automatically based on<br>
                        input/output ratio
                    </div>
                    <p>Flexible pooling regions</p>
                </div>
            </div>

            <div class="code-block">
def adaptive_max_pooling_2d(input_map, output_size):<br>
    h, w = input_map.shape<br>
    out_h, out_w = output_size<br>
    <br>
    output = np.zeros((out_h, out_w))<br>
    <br>
    for i in range(out_h):<br>
        for j in range(out_w):<br>
            # Calculate adaptive window boundaries<br>
            start_i = int(i * h / out_h)<br>
            end_i = int((i + 1) * h / out_h)<br>
            start_j = int(j * w / out_w)<br>
            end_j = int((j + 1) * w / out_w)<br>
            <br>
            window = input_map[start_i:end_i, start_j:end_j]<br>
            output[i, j] = np.max(window)<br>
    <br>
    return output
            </div>
            <br>
            <h4>Benefits:</h4>
            <ul>
                <li>Handles variable input sizes</li>
                <li>Useful for different image resolutions</li>
                <li>Common in modern architectures</li>
                <li>Flexible feature extraction</li>
            </ul>
        </div>

        <div class="section">
            <h3>‚öñÔ∏è Pooling Comparison</h3>
            <br>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Pooling Type</th>
                        <th>Best For</th>
                        <th>Characteristics</th>
                        <th>Common Use Cases</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Max Pooling</strong></td>
                        <td>Feature detection, edge detection</td>
                        <td>Preserves strongest activations</td>
                        <td>Early CNN layers, object detection</td>
                    </tr>
                    <tr>
                        <td><strong>Average Pooling</strong></td>
                        <td>Smooth feature reduction</td>
                        <td>Reduces noise, preserves distribution</td>
                        <td>Later CNN layers, when smoothing needed</td>
                    </tr>
                    <tr>
                        <td><strong>Global Max</strong></td>
                        <td>Classification, parameter reduction</td>
                        <td>Single max value per feature map</td>
                        <td>Replacing FC layers, modern architectures</td>
                    </tr>
                    <tr>
                        <td><strong>Global Average</strong></td>
                        <td>Classification, regularization</td>
                        <td>Single average value per feature map</td>
                        <td>ResNet, MobileNet, classification heads</td>
                    </tr>
                    <tr>
                        <td><strong>Adaptive</strong></td>
                        <td>Variable input sizes</td>
                        <td>Fixed output size, flexible windows</td>
                        <td>Object detection, segmentation networks</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h3>üîß TensorFlow/Keras Implementation</h3>
            <br>
            <div class="code-block">
# Different pooling layers in Keras<br>
model = keras.Sequential([<br>
    # Convolutional layer<br>
    keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),<br>
    <br>
    # Max pooling<br>
    keras.layers.MaxPooling2D((2, 2)),<br>
    <br>
    # Average pooling<br>
    keras.layers.AveragePooling2D((2, 2)),<br>
    <br>
    # Global pooling (choose one)<br>
    keras.layers.GlobalMaxPooling2D(),<br>
    # keras.layers.GlobalAveragePooling2D(),<br>
    <br>
    # Classification layer<br>
    keras.layers.Dense(10, activation='softmax')<br>
])<br>
<br>
# Adaptive pooling (using Lambda layer)<br>
keras.layers.Lambda(lambda x: tf.nn.adaptive_max_pool2d(x, (3, 3)))
            </div>
        </div>

        <div class="section">
            <h3>üìà Performance Considerations</h3>
            <br>
            <h4>Computational Efficiency:</h4>
            <ul>
                <li><span class="highlight">Global pooling</span>: Fastest (single operation per feature map)</li>
                <li><span class="highlight">Max pooling</span>: Fast (simple comparison operations)</li>
                <li><span class="highlight">Average pooling</span>: Moderate (requires summation and division)</li>
                <li><span class="highlight">Adaptive pooling</span>: Variable (depends on input/output size ratio)</li>
            </ul>
            <br>
            <h4>Memory Usage:</h4>
            <ul>
                <li>All pooling operations reduce memory usage</li>
                <li>Global pooling provides maximum memory reduction</li>
                <li>Larger pool sizes = greater memory savings</li>
            </ul>
        </div>

        <div class="section">
            <h3>üéØ Key Takeaways</h3>
            <br>
            <div class="pooling-demo">
                <div class="pooling-type">
                    <h4>‚úÖ Do</h4>
                    <ul>
                        <li>Use max pooling for feature detection</li>
                        <li>Use global pooling to replace FC layers</li>
                        <li>Consider adaptive pooling for variable inputs</li>
                        <li>Experiment with different pool sizes</li>
                    </ul>
                </div>
                
                <div class="pooling-type">
                    <h4>‚ùå Don't</h4>
                    <ul>
                        <li>Over-pool early in the network</li>
                        <li>Use large pool sizes without testing</li>
                        <li>Ignore the impact on gradient flow</li>
                        <li>Forget about stride effects</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>üöÄ Next Steps</h3>
            <ul>
                <li>Experiment with different pooling strategies in your CNN architectures</li>
                <li>Try combining multiple pooling types in the same network</li>
                <li>Explore learnable pooling alternatives like strided convolutions</li>
                <li>Study modern architectures and their pooling choices</li>
                <li>Implement custom pooling operations for specific tasks</li>
            </ul>
        </div>

        <div class="lecture-header" style="margin-top: 30px;">
            <h3>üéì Congratulations!</h3>
            <p>You now understand CNN pooling operations and their applications!</p>
            <p><em>Ready to dive deeper into CNN architectures?</em></p>
        </div>
    </div>
</body>
</html>
